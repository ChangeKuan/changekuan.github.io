<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>多线程学习笔记</title>
    <url>/changekuan.github.io/2020/03/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\changekuan.github.io\assets\css\APlayer.min.css"><script src="\changekuan.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一节-基础概念"><a href="#第一节-基础概念" class="headerlink" title="第一节 基础概念"></a>第一节 基础概念</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并行：在同一时间点发生。<br>并发：在某个时间段内同时发生。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程：<strong>运行起来了</strong>的可执行文件。<br>线程：代码的一条执行通路，可以通过自己写代码来创建其他线程。<br>主线程：进程执行起来了之后，就会有一个唯一的主线程默默启动，寿命和进程同步。<br>多线程：一个进程里，多个线程并发进行。<strong>但是如果多个线程同时去访问一个资源的话，很容易出问题。</strong></p>
<h2 id="并发的实现方法"><a href="#并发的实现方法" class="headerlink" title="并发的实现方法"></a>并发的实现方法</h2><p>1、创建多个进程（进程之间的通信：管道文件，信息队列，共享内存，socket通信）<br>2、单独一个进程创建多个线程（每个线程有自己独立的运行路径，所有线程共享进程内存。<strong>需要考虑到数据的一致性</strong>）<br>所以优先考虑多线程的并发技术使用。</p>
<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>C++11的新标准线程库，增加了对多线程的支持，可以执行大大提高。（以往：windows：createthread()使用创建线，linux:pthread_create，以往的基本不能跨平台）</p>
<h1 id="第二节-线程的创建"><a href="#第二节-线程的创建" class="headerlink" title="第二节 线程的创建"></a>第二节 线程的创建</h1><h2 id="thread-，join-，detach-，joinable"><a href="#thread-，join-，detach-，joinable" class="headerlink" title="thread()，join()，detach()，joinable()"></a>thread()，join()，detach()，joinable()</h2><pre><code class="cpp">void myprint() {
    cout &lt;&lt; &quot;我自己创造的线程1&quot; &lt;&lt; endl;

    cout &lt;&lt; &quot;线程1结束&quot; &lt;&lt; endl;
}

class TA {

    int &amp;m_i;
public:

    TA(int&amp; i) :m_i(i) {}

    void operator()(){//重载括号，线程入口
        cout &lt;&lt; &quot;m_i 的值为&quot; &lt;&lt;m_i&lt;&lt; endl;

        cout &lt;&lt; &quot;线程2结束&quot; &lt;&lt; endl;
    }
};

int main(){
    //自己创建一个线程，也要从一个函数开始。主线程结束了，如子线程没有执行完毕，可能会被强行终结。
    //现在就是有两条线路在跑。即使一条路堵住了，不耽误另一条执行
    //thread是一个类，括号里的参数myprint是可调用对象
    thread myobj(myprint);//创建了线程，入口是myprint函数

    if (myobj.joinable()) {
        cout &lt;&lt; &quot;joinable == true&quot; &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;joinable==false&quot; &lt;&lt; endl;
    }

    myobj.join();//阻塞主线程，希望主线程等待子线程，等我子线程执行完再放行。不添加join，可能子线程还没执行完，你就结束了。
    //myobj.detach();//使用了之后，就不能改join了

    int myi = 6;
    TA ta(myi);//使用了构造函数。参数引用进去的，有隐患。在主线程里，如果主线程结束了，就不能打印它的值了
    thread myobj2(ta);//使用类对象来创建子线程。这里调用了拷贝构造函数
    myobj2.join();
    //Q：一旦调用了detach，主线程没了，我还能使用这个类吗，还能使用他的成员函数吗？
    //A：可以。ta对象已经被复制到子线程中了，生成了一个新的类对象。二者没有关系了

    cout &lt;&lt; &quot;i love china1&quot; &lt;&lt; endl;//主线程,从main函数开始执行
    cout &lt;&lt; &quot;i love china2&quot; &lt;&lt; endl;

    return 0;
}</code></pre>
<h2 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h2><p>建议值传递，尽量不要使用引用和传指针。不要使用隐式类型转换，在创建线程的时候就把类型转换好。</p>
<pre><code class="cpp">//void myprint(const int&amp; i, char* mprint) {
void myprint(const int&amp; i, const string &amp;mprint) {//正确写法，用引用来接参数
    cout &lt;&lt; i &lt;&lt; endl;
    cout &lt;&lt; mprint &lt;&lt; endl;
}

void myprint2(unique_ptr&lt;int&gt; up) {//正确写法，用引用来接参数
    //cout &lt;&lt; i &lt;&lt; endl;
    //cout &lt;&lt; mprint &lt;&lt; endl;
}

class A {

public:
    int m_a;
    A(int a):m_a(a){
        cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;
    }

    void thread_work(int i) {
        cout &lt;&lt; &quot;任意成员函数thread_work启动&quot; &lt;&lt; endl;
    }
};

void myprint3(A a) {
    cout &lt;&lt; a.m_a &lt;&lt; endl;
    //cout &lt;&lt; mprint &lt;&lt; endl;
}

int main(){
    int i = 1;
    int&amp; myarray = i;
    char buf[] = &quot;this is a test&quot;;
    //thread myobj(myprint, myarray, buf);//函数名，函数的各参数。不要使用引用和传指针。有隐患
    thread myobj(myprint, i, string(buf));//正确写法,在创建线程的时候就把类型转换好，用临时的对象做参数来赋值，它一定会在进程结束前被构造出来。不论join还是detach
    myobj.join();

    A a(12);
    std::thread myobj2(myprint3,std::ref(a));//a在线程里会被修改
    //往线程里传递类对象的参数，不论你是不是引用，系统会默认使用拷贝，原来的主线程里的不会被改变。如果我想要要改，不希望被拷贝，则使用std::ref
    myobj2.join();

    //传递智能指针.需要使用move函数，才能正确
    unique_ptr&lt;int&gt; myp(new int(100));
    std::thread myobj3(myprint2, std::move(myp));
    myobj3.join();

    //用任意的成员函数来作为线程的入口
    A a2(10);
    std::thread myobj4(&amp;A::thread_work, std::ref(a2), 15);//入口：类函数，告诉你是具体哪个对象的函数，函数的参数……。也可把std::ref(a2)改成&amp;a2
    myobj4.join();
}</code></pre>
<h2 id="容器管理线程"><a href="#容器管理线程" class="headerlink" title="容器管理线程"></a>容器管理线程</h2><pre><code class="cpp">    void myprint(int num) {
    cout &lt;&lt; &quot;myprint线程开始了，编号：&quot; &lt;&lt; num &lt;&lt; endl;

    cout &lt;&lt; &quot;myprint线程结束了，编号：&quot; &lt;&lt; num &lt;&lt; endl;
    return;
}

int main(){
//创建和等待多个线程
    vector&lt;thread&gt; mythreads;//使用容器管理各个线程
    for (int i = 0; i &lt; 10; i++) {
        mythreads.push_back(thread(myprint, i));//创建了十个线程.执行顺序是乱的，很复杂，很随机
    }
    for (auto iter = mythreads.begin(); iter != mythreads.end();++iter) {
        iter-&gt;join();//等待十个线程
    }

    cout &lt;&lt; &quot;i love china&quot; &lt;&lt; endl;

    return 0;
}</code></pre>
<h1 id="互斥量和锁"><a href="#互斥量和锁" class="headerlink" title="互斥量和锁"></a>互斥量和锁</h1><h2 id="mutex，lock-，unlock-，lock-guard"><a href="#mutex，lock-，unlock-，lock-guard" class="headerlink" title="mutex，lock()，unlock()，lock_guard"></a>mutex，lock()，unlock()，lock_guard</h2><p>对于只读数据，不怎么需要特别注意的地方.对于有读有写的数据，比如2个写，八个来读，如果没有特别处理，会出问题。所以读的时候不能写，写的时候不能读，写的时候其他线程不能读写.<br>引入互斥量mutex的概念，使用lock（）加锁，只有一个线程能够锁定成功，成功的标志是返回了。没成功就是一直会等待锁成功。<br>lock()和unlock()成对使用（<strong>这里的成对是指每个分支要成对，不是数量上的成对，比如if有两个出口，两个出口都要写unlock()</strong>），在需要保护共享数据的地方加。<br>怕你忘记。所以有一个东西叫lockguard的类模板，帮你自动lock()，unlock()。用了lockguard另外两个就不许用了。原理，lockguard构造即执行了lock()，它析构的时候会执行unlock()。可以使用{}指定lockguard的作用范围。</p>
<p>死锁问题，必须有两个互斥量以上才有可能发生。比如：线程A：正在锁金锁，锁完之后，它准备去锁银锁……被切换了。线程B：正在锁银锁，银锁锁完了，它准备去锁金锁……<br>解决办法：保证上锁的顺序一致即可。大家都先锁金锁再上银锁。<br>std::lock(互斥锁1，互斥锁2，……)函数使用。在分别上锁的时候，如果遇到不能上锁的情况下，它会先释放自己已经锁了的，过一会再来尝试</p>
<pre><code class="cpp">vector&lt;int&gt; shared_v = { 1,2,3 };//共享数据
class A {
public:
    void inMsgRecvQueue() {//线程1，插入命令到消息队列
        for (int i = 0; i &lt; 10000; i++) {
            cout &lt;&lt; &quot;插入命令：&quot; &lt;&lt; i &lt;&lt; endl;

            std::lock(my_mutex1, my_mutex2);//相当于每一个互斥量执行lock操作，
            std::lock_guard&lt;mutex&gt; sbgurad1(my_mutex1, std::adopt_lock);//智能lock,构造时会自动执行lock函数。但是前面已经执行了lock操作，需要添加std::adopt_lock参数来避免问题
            std::lock_guard&lt;mutex&gt; sbgurad2(my_mutex2, std::adopt_lock);//智能lock,构造时会自动执行lock函数。但是前面已经执行了lock操作，需要添加std::adopt_lock参数来避免问题
            msgRecvQueue.push_back(i);

        }
    }

    void outMsgRecvQueue() {//线程2，读取命令到消息队列
        for (int i = 0; i &lt; 10000; i++) {
            my_mutex1.lock();//上锁
            my_mutex2.lock();//上锁
            if (!msgRecvQueue.empty()) {
                //消息不为空
                int command = msgRecvQueue.front();
                msgRecvQueue.pop_front();
                //处理数据
                my_mutex1.unlock();
                my_mutex2.unlock();
            }
            else {
                //消息为空
                cout &lt;&lt; &quot;读取命令，但是消息队列是空的&quot; &lt;&lt; endl;
                my_mutex1.unlock();//因为有两个出口，所以每个出口都要写上unlock
                my_mutex2.unlock();
            }
        }
    }
private:
    std::list&lt;int&gt; msgRecvQueue;//玩家命令
    std::mutex my_mutex1;//创建一个互斥量
    std::mutex my_mutex2;
};

void myprint(int num) {
    cout &lt;&lt; &quot;id:&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;线程打印shared_v数据&quot; &lt;&lt; shared_v[0] &lt;&lt; shared_v[1] &lt;&lt; shared_v[2] &lt;&lt; endl;
}

int main(){
    A myobj;

    std::thread mythread(&amp;A::outMsgRecvQueue, &amp;myobj);//第二个参数是引用，这样才能保证操作的是同一个对象
    std::thread mythread2(&amp;A::inMsgRecvQueue, &amp;myobj);//第二个参数是引用，这样才能保证操作的是同一个对象

    mythread.join();
    mythread2.join();

    return 0;
}
</code></pre>
<h1 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h1><h2 id="try-lock-，release"><a href="#try-lock-，release" class="headerlink" title="try_lock()，release()"></a>try_lock()，release()</h2><p>uniquelock里面的成员函数：内置unlock（）的作用：就是假设你有时候相处离别的非共享代码的时候想解锁了，可以手动设置成unlock。弄完了再回来加锁。 try_lock（），尝试加锁，成功返回true，失败返回false。<br>release（）释放对于mutex的管理权，sbguard和mutex取消关系，返回的是互斥量的指针。<br>则需要你自己手动unlock。std::mutex * ptx = sbgurad2.release();  ptx-&gt;unlock();<br>锁住的代码少，粒度小，执行效率高。锁住的代码多，粒度大，效率低。<br>uniquelock的所有权的传递，一个uniquelock和一个mutex配对，所有权可以转移。使用std::unique_lock<a href="std::mutex">std::mutex</a> sbgurad2(std::move(sbgurad1));实现转移。也可以通过函数，构造临时对象，获得所有权，然后return给调用函数的对象。</p>
<pre><code class="cpp">class A {
public:
    void inMsgRecvQueue() {//线程1，插入命令到消息队列
        for (int i = 0; i &lt; 10000; i++) {
            cout &lt;&lt; &quot;插入命令：&quot; &lt;&lt; i &lt;&lt; endl;

            my_mutex1.lock();//相当于每一个互斥量执行lock操作，
            std::lock_guard&lt;std::mutex&gt; sbgurad1(my_mutex1, std::adopt_lock);//智能lock,构造时会自动执行lock函数。前面已经执行了lock操作，需要添加std::adopt_lock参数来避免问题

            std::unique_lock&lt;std::mutex&gt; sbgurad2(my_mutex2, std::try_to_lock);//unique_lock比lockguard好用，但是效率低，占用多,try_to_lock（不能先lock）不会卡住，拿不到锁就马上返回走人

            if (sbgurad2.owns_lock()) {//检查是否拿到了锁，和try_lock使用场景类似
                msgRecvQueue.push_back(i);
            }
            else {
                cout &lt;&lt; &quot;没拿到锁，只能干点别的事&quot; &lt;&lt; endl;
            }


        }
    }

    void outMsgRecvQueue() {//线程2，读取命令到消息队列
            for (int i = 0; i &lt; 10000; i++) {

            if (!msgRecvQueue.empty()) {

                std::unique_lock&lt;std::mutex&gt; sbguarde1(my_mutex1);
                std::unique_lock&lt;std::mutex&gt; sbguarde2(my_mutex2);
                //std::chrono::milliseconds dura(20000);//休息20000毫秒
                //std::this_thread::sleep_for(dura);

                if (!msgRecvQueue.empty()) {
                    //消息不为空
                    int command = msgRecvQueue.front();
                    msgRecvQueue.pop_front();
                    //处理数据
                }
            }
            //消息为空
            cout &lt;&lt; &quot;读取命令，但是消息队列是空的&quot; &lt;&lt; endl;
        }
    }
private:
    std::list&lt;int&gt; msgRecvQueue;//玩家命令
    std::mutex my_mutex1;//创建一个互斥量
    std::mutex my_mutex2;
};</code></pre>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>call_once(),该函数的第二个参数，是一个函数名，能够保证这个函数只被调用一次。具备互斥量的能力。配合使用once_flag，标记该函数是否已经被调用了。如果已经被调用了，就不会再被调用了</p>
<pre><code class="cpp">std::mutex mymutex1;
std::once_flag g_flag;

class myCAS {

    static void createInstance() {//我们需要的只被调用一次的函数
        std::chrono::milliseconds dura(20000);
        std::this_thread::sleep_for(dura);

        cout &lt;&lt; &quot;createInstance()被执行了&quot; &lt;&lt; endl;

        m_instance = new myCAS();

        static laJiHuiShou cl;
    }

private:
    myCAS() {}//把构造函数私有化了，不能轻易构造对象了
    static myCAS* m_instance;//静态成员


public:
    static myCAS * GetInstance() {//只给第一次出现的，进行new对象操作

        //if (m_instance == NULL) {//双重认定
        //    if (m_instance == NULL) {
        //        std::unique_lock&lt;std::mutex&gt; sbguard(mymutex1);//如果是子线程来生成单例模式下的对象，需要进行加锁，防止

        //        m_instance = new myCAS();

        //        static laJiHuiShou cl;
        //    }
        //}

        //上方代码更高效

        std::call_once(g_flag, createInstance);//两个线程执行到这里，只有一个会被成功执行

        cout &lt;&lt; &quot;call_once()被执行完毕&quot; &lt;&lt; endl;

        return m_instance;
    }

    class laJiHuiShou {//为了完美，垃圾主动回收一下
    public:
        ~laJiHuiShou() {
            if (myCAS::m_instance) {
                delete myCAS::m_instance;
                myCAS::m_instance = NULL;
            }
        }
    };

};

int main(){
    //类静态变量初始化
    myCAS *myCAS::m_instance = NULL;

    //设计模式
    //单例设计模式：由某个或者某些特殊的类，属于这个类的对象，只能创建一个 。我就只对这一个对象进行操作
    myCAS* p_a = myCAS::GetInstance();
    //建议在主线程中生成对象之后，把所有的数据加载完之后，改成只读模式。后面对其进行独操作就不用特地上锁了

}</code></pre>
<h1 id="条件变量condition-variable"><a href="#条件变量condition-variable" class="headerlink" title="条件变量condition_variable"></a>条件变量condition_variable</h1><h2 id="wait-，notify-one"><a href="#wait-，notify-one" class="headerlink" title="wait()，notify_one()"></a>wait()，notify_one()</h2><p>wait()：等一个东西。如果第二个参数的表达式返回的是false，解锁互斥量，开始阻塞。阻塞至其他线程调用notify_one()函数为止.唤醒之后，就会不断获取锁。获取到之后，上锁。如果wait()没有第二个参数，则默认返回false<br>notify_one()：唤醒一个在wait()的线程.假如没有线程在wait()，这个唤醒就没意义</p>
<pre><code class="cpp">class A {
public:
    void inMsgRecvQueue() {//线程1，插入命令到消息队列
        for (int i = 0; i &lt; 10000; i++) {

            cout &lt;&lt; &quot;inMsgRecvQueue执行，插入一个元素&quot; &lt;&lt; i &lt;&lt; endl;

            std::unique_lock&lt;std::mutex&gt; sbguard1(my_mutex1);

            msgRecvQueue.push_back(i);

            my_conditionV.notify_one();//唤醒一个在wait的线程.假如没有线程在wait，这个唤醒就没意义
        }
        return;
    }

    void outMsgRecvQueue() {//线程2，读取命令到消息队列
        int command = 0;
        while (true) {
            std::unique_lock&lt;std::mutex&gt; sbguard1(my_mutex1);//上锁互斥量
            my_conditionV.wait(sbguard1, [this] {//wait（）,等一个东西。如果第二个参数的表达式返回的是false，解锁互斥量，开始阻塞。
                                                 //阻塞至其他线程调用notify_one（）函数为止.唤醒之后，就会不断获取锁。获取到之后，上锁
                                                    //如果wait（）没有第二个参数，则默认返回false
                if (!msgRecvQueue.empty())
                    return true;
                return false;
            });

            //这里不一定立马竞争锁成功了，可能等取命令竞争完了，插入了很多条数据了
            command = msgRecvQueue.front();
            msgRecvQueue.pop_front();
            cout &lt;&lt; &quot;outMsgRecvQueue执行，取出一个元素&quot; &lt;&lt; command &lt;&lt; &quot;,threadID&quot;&lt;&lt;std::this_thread::get_id()&lt;&lt;endl;
            sbguard1.unlock();//因为我已经取完了，就先解锁，让写操作继续进行。线程还不够完美：我们应该把里面的命令全部取出


        }

    }
private:
    std::list&lt;int&gt; msgRecvQueue;//玩家命令
    std::mutex my_mutex1;//创建一个互斥量
    std::condition_variable my_conditionV;
};

int main(){
//条件变量condition_variable，wait（），notify_one（）：唤醒一个。notify_all()：唤醒全部在wait的线程
    A myobja;
    std::thread myOutMsg(&amp;A::outMsgRecvQueue, &amp;myobja);//myobja是引用，因为要和inMsgRecvQueue操作共用
    std::thread myInMsg(&amp;A::inMsgRecvQueue, &amp;myobja);
    myInMsg.join();
    myOutMsg.join();

    return 0;
    }</code></pre>
<h1 id="async函数模板"><a href="#async函数模板" class="headerlink" title="async函数模板"></a>async函数模板</h1><h2 id="std-future-std-launch"><a href="#std-future-std-launch" class="headerlink" title="std::future,std::launch"></a>std::future,std::launch</h2><pre><code class="cpp">class A {
public:
    int mythread(int mypra) {
        cout &lt;&lt; &quot;线程开始执行啦，threadid为&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;
        std::chrono::milliseconds dura(5000);
        std::this_thread::sleep_for(dura);
        cout &lt;&lt; mypra &lt;&lt; endl;

        cout &lt;&lt; &quot;线程执行结束啦，threadid为&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;
        return 5;
    }
};

int main(){
    //std::async,std::future,std::launch(线程会延迟到)
    //希望线程返回结果
    //async是一个函数模板，启动一个异步任务：自动创建一个线程，并开始执行对应线程的入口函数
    A a;
    int tmppra = 12;
    cout &lt;&lt; &quot;main启动，threadid=&quot; &lt;&lt; std::this_thread::get_id &lt;&lt; endl;
    std::future&lt;int&gt; result = std::async(&amp;A::mythread,&amp;a,tmppra);//创建了一个线程，入口函数为mythread（这个函数必须要返回一个值，不然后面有问题）。rusult还没这么快得到值，将来会拿到。先不管了，程序往下运行
    //std::future&lt;int&gt; result = std::async(std::launch::deferred,&amp;A::mythread,&amp;a,tmppra);//deferred延迟调用，遇到get和wait使用之后再会开始调用
    //std::future&lt;int&gt; result = std::async(std::launch::async, &amp;A::mythread, &amp;a, tmppra);//立即开始执行，不会特地等get和wait的使用
    cout &lt;&lt; &quot;continue……！&quot; &lt;&lt; endl;
    int def = 0;
    cout &lt;&lt; result.get() &lt;&lt; endl;//会一直卡在这里，直到result拿到了值，才会继续进行。get（）只能调用一次

    cout &lt;&lt; &quot;i love china!&quot; &lt;&lt; endl;

    return 0;
    //补充
    //std::async:创建异步任务
    cout &lt;&lt; &quot;main&quot; &lt;&lt; std::this_thread::get_id &lt;&lt; endl;
    std::future&lt;int&gt; result = std::async(mythread);//参数deferred【延迟调用,不创建新线程，只在当前线程下进行任务】，async【强制创建任务】，std::async和std::thread的区别
                                                   //可能有时async不会创建新的线程。且返回值方便传递出去
                                                   //使用“或”符号，说明就是两个启动方式都有可能发生，随机二选一
                                                   //不使用参数，就两个启动方式都有可能发生，随机二选一
                                                   //如果有时资源紧张，thread操作可能会报异常

    //系统如何决定是async还是deferred
    std::future_status status = result.wait_for(std::chrono::seconds(0));//系统停在这里等待一秒钟.status保存result的状态：timeout，ready,deferred
                                                                         //也可以写成std::future_status status = result.wait_for(0s);
    if (status == std::future_status::deferred) {//如果asnyc的第一个参数被设置为std::launch::deferred，本条件成立
        cout &lt;&lt; &quot;线程延迟执行！&quot; &lt;&lt; endl;
        cout &lt;&lt; result.get() &lt;&lt; endl;
    }
    else if (status == std::future_status::ready) {//执行完了
        cout &lt;&lt; &quot;线程执行完了！&quot; &lt;&lt; endl;
        cout &lt;&lt; result.get() &lt;&lt; endl;
    }
    else if (status == std::future_status::timeout) {//超时
        cout &lt;&lt; &quot;超时了，线程还没有执行完！&quot; &lt;&lt; endl;
    }
    cout &lt;&lt; result.get() &lt;&lt; endl;
}</code></pre>
<h1 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h1><p>packaged_task的使用：把函数包装起来,实现更多接口。</p>
<pre><code class="cpp">    vector&lt; std::packaged_task&lt;int(int)&gt;&gt; myTask;

int mythread(int mypra) {
    cout &lt;&lt; &quot;线程开始执行啦，threadid为&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;
    std::chrono::milliseconds dura(5000);
    std::this_thread::sleep_for(dura);
    cout &lt;&lt; mypra &lt;&lt; endl;

    cout &lt;&lt; &quot;线程执行结束啦，threadid为&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;
    return 5;
}

int main(){
    //packaged_task的使用：把函数包装起来,实现更多接口
        //写法1
        //std::pakage_task
        //cout &lt;&lt; &quot;main启动，threadid=&quot; &lt;&lt; std::this_thread::get_id &lt;&lt; endl;
        //std::packaged_task&lt;int(int)&gt; mypt(mythread);//把mythread函数包装了起来,实现更多接口
        //std::thread t1(std::ref(mypt), 1);//1 是入口函数的参数
        //t1.join();
        //std::future&lt;int&gt; result = mypt.get_future();
        //cout &lt;&lt; result.get() &lt;&lt; endl;

        //写法2：
        std::packaged_task&lt;int(int)&gt; mypt([](int mypar) {
            cout &lt;&lt; &quot;线程开始执行啦，threadid为&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;
            std::chrono::milliseconds dura(5000);
            std::this_thread::sleep_for(dura);
            cout &lt;&lt; mypar &lt;&lt; endl;

            cout &lt;&lt; &quot;线程执行结束啦，threadid为&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;
            return 5;
            });

        myTask.push_back(std::move(mypt));

        std::packaged_task&lt;int(int)&gt; myptr2;
        auto iter = myTask.begin();
        myptr2 = std::move(*iter);//vector里面的第一个对象就复制到myptr2了
        myTask.erase(iter);//删除vector第一个元素，iter也没用了
        std::thread t1(std::ref(myptr2), 1);//1 是入口函数的参数
        t1.join();
        std::future&lt;int&gt; result = myptr2.get_future();
        cout &lt;&lt; result.get() &lt;&lt; endl;
        return 0;
    }</code></pre>
<h1 id="线程之间值的传递"><a href="#线程之间值的传递" class="headerlink" title="线程之间值的传递"></a>线程之间值的传递</h1><h2 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h2><p>promise的对象用于线程之间传递数值。</p>
<pre><code class="cpp">void mythread(std::promise&lt;int&gt; &amp;tmp,int cal) {
    //
    cal++;
    cal *= 10;
    std::chrono::milliseconds dura(5000);
    std::this_thread::sleep_for(dura);

    int result = cal;

    tmp.set_value(result);//结果保存到了tmp中

    return;
}

    void mythread2(std::future&lt;int&gt;&amp; tmp) {
    auto result = tmp.get();
    cout &lt;&lt; &quot;mythread2得到值&quot; &lt;&lt; result &lt;&lt; endl;
    return;
}

int main(){
    //std::promise的作用：线程之间值传递
    std::promise&lt;int&gt; myprom;
    std::thread t1(mythread, std::ref(myprom), 180); //用myprom去获得得到的值。
    t1.join();

    std::future&lt;int&gt; fut = myprom.get_future();//fut即将得到myprom的值
    //auto result = fut.get();//get只能调用一次
    //cout &lt;&lt; &quot;result=&quot; &lt;&lt; result &lt;&lt; endl;

    std::thread t2(mythread2, std::ref(fut));
    t2.join();
}</code></pre>
<h2 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::future</h2><p>future的对象会在将来得到一个值。future的其他成员函数：枚举类型future_status，记录状态。</p>
<pre><code class="cpp">class A {
public:
    int mythread(int mypra) {
        cout &lt;&lt; &quot;线程开始执行啦，threadid为&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;
        std::chrono::milliseconds dura(3000);
        std::this_thread::sleep_for(dura);
        cout &lt;&lt; mypra &lt;&lt; endl;

        cout &lt;&lt; &quot;线程执行结束啦，threadid为&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;
        return 5;
    }
};

int main(){
    //future的其他成员函数：枚举类型future_status
    //async是一个函数模板，启动一个异步任务：自动创建一个线程，并开始执行对应线程的入口函数
    A a;
    int tmppra = 12;
    cout &lt;&lt; &quot;main启动，threadid=&quot; &lt;&lt; std::this_thread::get_id &lt;&lt; endl;
    std::future&lt;int&gt; result = std::async(&amp;A::mythread, &amp;a, tmppra);//创建了一个线程，入口函数为mythread（这个函数必须要返回一个值，不然后面有问题）。rusult还没这么快得到值，将来会拿到。先不管了，程序往下运行
    cout &lt;&lt; &quot;continue……！&quot; &lt;&lt; endl;

    std::future_status status = result.wait_for(std::chrono::seconds(6));//系统停在这里等待一秒钟.status保存result的状态：timeout，ready,deferred
    if (status == std::future_status::timeout) {//超时
        cout &lt;&lt; &quot;超时了，线程还没有执行完！&quot; &lt;&lt; endl;
    }
    else if (status == std::future_status::ready) {//执行完了
        cout &lt;&lt; &quot;线程执行完了！&quot; &lt;&lt; endl;
        cout &lt;&lt; result.get() &lt;&lt; endl;
    }else if (status == std::future_status::deferred) {//如果asnyc的第一个参数被设置为std::launch::deferred，本条件成立
        cout &lt;&lt; &quot;线程延迟执行！&quot; &lt;&lt; endl;
        cout &lt;&lt; result.get() &lt;&lt; endl;
    }

    cout &lt;&lt; &quot;i love china&quot; &lt;&lt; endl;
    return 0;
}</code></pre>
<p>future的对象get只能用一次，假如我多个线程想要获取某个结果，怎么办。这时shared_future就派上用场了。</p>
<pre><code class="cpp">void mythread(std::promise&lt;int&gt;&amp; tmp, int cal) {
    //
    cout &lt;&lt; &quot;mythread1开始执行，id：&quot; &lt;&lt; std::this_thread::get_id &lt;&lt; endl;
    cal *= 10;
    std::chrono::milliseconds dura(5000);
    std::this_thread::sleep_for(dura);

    int result = cal;

    tmp.set_value(result);//结果保存到了tmp中

    return;
}

void mythread2(std::shared_future&lt;int&gt;&amp; tmp) {

    cout &lt;&lt; &quot;mythread2开始执行，id：&quot; &lt;&lt; std::this_thread::get_id &lt;&lt; endl;
    auto result = tmp.get();
    cout &lt;&lt; &quot;mythread2得到值&quot; &lt;&lt; result &lt;&lt; endl;
    return;
}

int main(){
    //future的其他成员函数：shared_future。get只能用一次，假如我多个线程想要获取某个结果，怎么办。
    std::promise&lt;int&gt; myprom;
    std::thread t1(mythread, std::ref(myprom), 180); //用myprom去获得得到的值。
    t1.join();

    //std::future&lt;int&gt; fut = myprom.get_future();//fut即将得到myprom的值
    //auto result = fut.get();//future类型的对象的get（）只能调用一次!!!!!!!!!!!get()函数的设计，是一个移动语义。所以移动完，fut已经空了
    //cout &lt;&lt; &quot;result=&quot; &lt;&lt; result &lt;&lt; endl;
    //std::shared_future&lt;int&gt; fut_s(std::move(fut));//或者std::shared_future&lt;int&gt; fut_s(fut.share())

    std::shared_future&lt;int&gt; fut_s(myprom.get_future());
    auto tmpFut = fut_s.get();//此时的fut_s就是可以多次被调用get（）函数
    cout &lt;&lt; &quot;fut_s第一次get（），值为：&quot; &lt;&lt;tmpFut&lt;&lt; endl;

    std::thread t2(mythread2, std::ref(fut_s));
    t2.join();

    cout &lt;&lt; &quot;i love china&quot; &lt;&lt; endl;

    return 0;
}</code></pre>
<h1 id="原子操作-atomic"><a href="#原子操作-atomic" class="headerlink" title="原子操作 atomic"></a>原子操作 atomic</h1><p>多个线程对一个变量进行读写操作，不加锁肯定会出现冲突错误。所以，引入原子操作：不会被打断的程序执行片段。就可以不用加锁了，但是只能针对一个变量的进行原子操作。<br>针对++，–，+=，&amp;=，等操作支持，a=a+1不支持。一般用于计数统计。</p>
<pre><code class="cpp">std::atomic&lt;int&gt; g_mycout = 0;//封装了一个类型为int的原子对象
//std::mutex g_mutex;

void mythread() {
    for (int i = 0; i &lt; 10000000; i++) {
        //g_mutex.lock();
        g_mycout++;//此时它是原子操作，不会被打断了
        //g_mutex.unlock();
    }
    return;
}
int main(){
    std::thread mytobj1(mythread);
    std::thread mytobj2(mythread);
    mytobj1.join();
    mytobj2.join();

    cout &lt;&lt; g_mycout &lt;&lt; endl;

    cout &lt;&lt; &quot;执行完毕&quot; &lt;&lt; endl;
}</code></pre>
<h1 id="windows临界区以及特殊的互斥量mutex"><a href="#windows临界区以及特殊的互斥量mutex" class="headerlink" title="windows临界区以及特殊的互斥量mutex"></a>windows临界区以及特殊的互斥量mutex</h1><p>windows临界区，类似于c++11的mutes，相同的线程里面对于相同的临界区变量，可以允许多次加锁，但是也相应地调用一样多次的解锁，用类的构造函数和析构函数来实现临界区的自动进入和自动退出。<br>相类似的，递归的独占互斥量recursive_mutex。允许一个互斥量多次lock<br>带超时的互斥量timed_mutex和recursive_timed_mutex。超时了就不等了。接口：try_lock_for(时长)返回true就是获取了锁。try_lock_until(时间点)</p>
<pre><code class="cpp">#define __WINDOWSJQ_

class A {
public:
    A() {
#ifdef __WINDOWSJQ_
        InitializeCriticalSection(&amp;my_winsec);
#endif // __WINDOWSJQ_

    }
    void inMsgRecvQueue() {//线程1，插入命令到消息队列
        for (int i = 0; i &lt; 10000; i++) {
            cout &lt;&lt; &quot;插入命令：&quot; &lt;&lt; i &lt;&lt; endl;
#ifdef __WINDOWSJQ_
            EnterCriticalSection(&amp;my_winsec);
            msgRecvQueue.push_back(i);
            LeaveCriticalSection(&amp;my_winsec);

#else
            std::lock(my_mutex1, my_mutex2);//相当于每一个互斥量执行lock操作，
            std::lock_guard&lt;mutex&gt; sbgurad1(my_mutex1, std::adopt_lock);//智能lock,构造时会自动执行lock函数。但是前面已经执行了lock操作，需要添加std::adopt_lock参数来避免问题
            std::lock_guard&lt;mutex&gt; sbgurad2(my_mutex2, std::adopt_lock);//智能lock,构造时会自动执行lock函数。但是前面已经执行了lock操作，需要添加std::adopt_lock参数来避免问题
            msgRecvQueue.push_back(i);
#endif // __WINDOWSJQ_

        }
    }

    void outMsgRecvQueue() {//线程2，读取命令到消息队列
        for (int i = 0; i &lt; 10000; i++) {
#ifdef __WINDOWSJQ_
            EnterCriticalSection(&amp;my_winsec);
            if (!msgRecvQueue.empty()) {
                //消息不为空
                int command = msgRecvQueue.front();
                msgRecvQueue.pop_front();
                //处理数据
                LeaveCriticalSection(&amp;my_winsec);
            }
            else {
                //消息为空
                cout &lt;&lt; &quot;读取命令，但是消息队列是空的&quot; &lt;&lt; endl;
                LeaveCriticalSection(&amp;my_winsec);
            }
#else // DEBUG

            my_mutex1.lock();//上锁
            my_mutex2.lock();//上锁
            if (!msgRecvQueue.empty()) {
                //消息不为空
                int command = msgRecvQueue.front();
                msgRecvQueue.pop_front();
                //处理数据
                my_mutex1.unlock();
                my_mutex2.unlock();
            }
            else {
                //消息为空
                cout &lt;&lt; &quot;读取命令，但是消息队列是空的&quot; &lt;&lt; endl;
                my_mutex1.unlock();//因为有两个出口，所以每个出口都要写上unlock
                my_mutex2.unlock();
            }
            #endif
        }
    }
private:
    std::list&lt;int&gt; msgRecvQueue;//玩家命令
    std::mutex my_mutex1;//创建一个互斥量
    std::mutex my_mutex2;
#ifdef __WINDOWSJQ_
    CRITICAL_SECTION my_winsec;
#endif // 临界区__WINDOWSJQ_

};

int main(){
    A myobj;

    std::thread mythread(&amp;A::outMsgRecvQueue, &amp;myobj);//第二个参数是引用，这样才能保证操作的是同一个对象
    std::thread mythread2(&amp;A::inMsgRecvQueue, &amp;myobj);//第二个参数是引用，这样才能保证操作的是同一个对象

    mythread.join();
    mythread2.join();
}</code></pre>
<h1 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h1><p>原子操作：读load（），写store（）<br>线程池：把一堆线程放到一起，统一管理，循环利用，用完放回去。场景假设：服务器为客户端提供服务，来一个客户端，服务器就为它创建一个新的线程。但是如果客户端特别多……创建线程很有可能创建失败了，后面就崩溃了。实现方法：程序启动时，一次性建好一定数量的线程<br>线程数量极限：2000个<br>数量建议：使用接口有指定数量，就严格按照数量来</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 学习笔记</title>
    <url>/changekuan.github.io/2020/02/27/Effective-C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\changekuan.github.io\assets\css\APlayer.min.css"><script src="\changekuan.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><pre><code class="cpp">int x;
std::size_t numDigits(int number);
class Widget;
template&lt;typename T&gt;
class GraphNode; </code></pre>
<p>1、即使对于 int x，我们也要习惯性称x为对象。<br>2、std：几乎是所有C++标准库元素的栖身地。平时使用程序库里的组件的时候都会略去前导std，养成习惯。<br>3、函数的声明式，其实是揭示其签名式对于</p>
<pre><code class="cpp">std::size_t numDigits(int number)</code></pre>
<p>对应签名式为std::size_t(int)</p>
<h3 id="定义式"><a href="#定义式" class="headerlink" title="定义式"></a>定义式</h3><p>1、用explicit修饰的构造函数，可以阻止被用来隐式类型转换。<br>2、只有新对象生成时会调用构造函数</p>
<pre><code class="cpp">Widget w2 = w1;//用到的是拷贝构造函数
Widget w2;//使用的是默认构造函数
w2 = w1;//是赋值操作</code></pre>
<p>3、尽可能避开不明确的行为</p>
<pre><code class="cpp">int *p  = 0; //p是null指针
std::cout &lt;&lt; *p;//对null取值，是不明确行为</code></pre>
<p>4、C++概念里的接口：函数签名式，Class里可访问的元素</p>
<h3 id="命名习惯"><a href="#命名习惯" class="headerlink" title="命名习惯"></a>命名习惯</h3><p>1、对于两个参数，一般可以lhs和rhs（左操作数，和右操作数）<br>2、示范时的class，不知道怎么命名，就Widget吧。<br>3、Widget * pw；//point to Widget</p>
<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h2><p>C++ 的四个次语言：<strong>C,Object-Oriented C++，Template C++，STL</strong><br>1、C。没有模板，没有异常，没有重载。<br>2、Object-Oriented C++。面向对象，封装，继承，多态<br>3、Template C++。泛型编程。<br>4、STL。容器，算法，迭代器</p>
<h2 id="用count，enum，inline来代替-define"><a href="#用count，enum，inline来代替-define" class="headerlink" title="用count，enum，inline来代替#define"></a>用count，enum，inline来代替#define</h2><p>使用#define是在预处理器中，使用它很有可能定义的名称未进入记号表而编译器不认识。<br>1、对于宏变量。推荐写成，例如：</p>
<pre><code class="cpp">const double AspectRatio = 1.653;//命名成大写开头的习惯，用于宏
enum {NumTurns = 5}；//NumTurns成为5的一个记号，仅仅记号而已，它没有地址</code></pre>
<p>2、对于宏函数。用inline代替</p>
<pre><code class="cpp">template&lt;typename T&gt;
inline void callWithMax(const T&amp; a,const T&amp; b){ //定义了一个callWithMax的宏函数
    f(a&gt;b?a:b);
}</code></pre>
<p>所以就是尽量避免使用预处理器。</p>
<h2 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h2><p>1、 </p>
<pre><code class="cpp">char greeting[] = &quot;hello&quot;;
const char * const p = greeting; //const pointer，const data。指针和指针指向的内容都是const类型的</code></pre>
<p>有些东西就是不希望它后期被意外修改，那就把它变成const。<br>2、迭代器</p>
<pre><code class="cpp">const std::vector&lt;int&gt;::iterator i;//pointer is const,value可动
std::vector&lt;int&gt;::const_iterator i;//value is const,pointer可动</code></pre>
<p>3、const型成员函数，不可以改变对象内任何非static成员变量，可用mutable来修饰非static成员变量的约束。</p>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p><strong>C++资源</strong>：内存，文件描述器，互斥锁，数据库连接，网络socket</p>
<h2 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h2><p>利用对象来管理资源，使用c++的析构函数自动调用机制确保资源被释放<br><strong>智能指针auto_ptr</strong>：类指针对象，自动对其调用delete。但是<strong>容不得重复</strong>，一个指针指定了独一无二的资源</p>
<pre><code class="cpp">std::auto_ptr&lt;classname&gt; name(func())</code></pre>
<p>stl的<strong>复制行为</strong>就容不得auto_ptr，引用计数型智慧指针share_ptr，追踪共有多少对象指向某笔资源，并在无人指向他的时候删除它。（环状引用无解）<br>但是他们只能做delete操作。删除array会有问题。以上适合heapbased资源管理。在初始化的时候取得资源。<br>用资源管理类来管理资源，对于share_ptr，可以自定“删除器”这样的话，就可以不是删除，可以改成其他操作，比如：解锁啥的<br>在资源管理类中提供对原始对象的访问：</p>
<h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>开启你活力新一天的建议</title>
    <url>/changekuan.github.io/2020/02/24/%E5%BC%80%E5%90%AF%E4%BD%A0%E6%B4%BB%E5%8A%9B%E6%96%B0%E4%B8%80%E5%A4%A9%E7%9A%84%E7%9D%A1%E7%9C%A0%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\changekuan.github.io\assets\css\APlayer.min.css"><script src="\changekuan.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="我想快速激活自己"><a href="#我想快速激活自己" class="headerlink" title="我想快速激活自己"></a>我想快速激活自己</h1><p>早晨起床后，通常都昏昏沉沉一个小时左右，想要快速激活自己，怎么办？早上起不来，想要快速激活自己，怎么办？让我们听听张展晖老师的回答。<br>这个问题有个前提条件，就是睡眠是否充足。<strong>如果睡眠不足，那快速充满活力只能是透支自己的身体。如果睡眠足，我们可以通过调整激素水平来快速充满活力。</strong></p>
<h1 id="睡眠与活力的关系"><a href="#睡眠与活力的关系" class="headerlink" title="睡眠与活力的关系"></a>睡眠与活力的关系</h1><p>我们每个人都体验过一夜熟睡后的神清气爽，活力满满。这个就和睡眠质量有关系。我们现在有很多智能设备生监测睡眠，里面会把睡眠分类。有深度睡眠、动眼睡眠和浅睡眠。<strong>深度睡眠就是负责我们肌肉恢复的，如果深度睡眠不足，早上起来就会觉得全身僵硬，浑身觉得紧。所以如果想肌肉恢复好，就需要有好的深度睡眠。</strong><br>现代研究发现，睡眠分为好几个阶段，不同阶段有着不同的功能，比如：<strong>快速眼动睡眠修复大脑，而非快速眼动睡眠中的深度睡眠，则是可以起到修复身体的作用。</strong><br>刚入睡时，人体处于浅睡眠期，之后慢慢过渡到深度睡眠期，这时你心跳变慢，呼吸沉稳，劳累了一天的肌肉组织和骨骼完全放松，整个身体进入深度修复状态，免疫系统也会得到加强。<strong>深度睡眠保持一段时间之后，就会进入快速眼动睡眠阶段。需要有足够时间让这个循环来回交替。所以7到8小时左右的睡眠对身体是必须的。</strong><br>只有睡眠充足了，身体肌肉和大脑才会得到足够的休息，你第二天早起的状态才会好，如果长期熬夜加班，每天睡眠只有5到6小时，这时不光第二天起床后睡不醒，而且免疫力也会低下，容易得发烧感冒。<strong>如果再去运动，身体状态会更差，免疫力更加低下，因为身体无法从睡眠中得到修复。</strong><br>那你会问了，遇到赶工作进度或者加班多时怎么办？你可以午饭后找个安静的地方，或者趴桌子上打个盹，另外就是在周末通过多睡一会儿，把丢失的睡眠时间补回来一些。这样早上睡不醒的状态会好很多。<br>刚才咱们说的是睡眠不足的情况，<strong>那另一种情况，睡得挺足的，起床的时候还感觉睡不醒怎么办？</strong></p>
<h1 id="血清素激素"><a href="#血清素激素" class="headerlink" title="血清素激素"></a>血清素激素</h1><p>一个关键的方法是调整你脑内的血清素激素。当人体分泌血清素的时候，人就会朝气蓬勃，因为血清素开始活动的时候，就会发出刺激，使人头脑保持清醒的状态。如果血清素活跃性很高的话，人心也会处于一种平静、安稳的状态，减少焦虑，工作效率也会大幅提升。<strong>总之早晨人能清醒地醒来，白天平静地做事，都是血清素在发挥作用。</strong></p>
<h2 id="拉开窗帘睡觉。"><a href="#拉开窗帘睡觉。" class="headerlink" title="拉开窗帘睡觉。"></a>拉开窗帘睡觉。</h2><p>第一个提高血清素简单的方法，就是拉开窗帘睡觉。阳光的照射会刺激血清素的合成，然后刺激脉冲会传递到整个大脑，让大脑进入清醒的状态。如果拉着窗帘，屋子里黑黑的，闹钟直接响起，这种情况下，你的血清素实际并未分泌，就会出现睡不醒的感觉，因而引发心情郁闷、”什么事都不想做“、”不想被从被窝里出来“等感受。<strong>因为血清素只有在受到日光刺激的时候才开始合成。</strong>所以建议拉开窗帘睡觉，可能在闹钟之前，人就可以自然醒来了，就会觉得睡得真舒服。<strong>另外如果房间光线不足，也可以考虑起床后室外散步一会儿，接受了阳光照射后，同样我们会感觉清醒很多。注意，如果你是容易失眠、凌晨容易清醒的人，就不要拉开窗帘了，因为凌晨熹微的光线容易进一步破坏你本就脆弱的睡眠。</strong>（只有睡眠充足的人才建议“快速激活”，睡眠不足还是先补足睡眠吧）。</p>
<h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><p>第二个关于提高血清素的方式是运动，当你起床后在室内或者室外散步、慢跑、爬楼或深蹲，就可以促进血清素的分泌。如果睡前就把跑鞋和运动服准备好，起床就穿上运动服，那早起运动会容易很多。这种运动10到20分钟就足够了。</p>
<h2 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h2><p>第三个有助于血清素提升的方式是饮食。饮食要平衡，是因为合成血清素需要人体不能合成的色氨酸。<strong>色氨酸在肉类，大豆，乳制品中的含量非常丰富。</strong>如果挑食可能就会因为缺乏而无法满足血清素合成的基础条件了。</p>
<h1 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h1><p>除了提高血清素以外，还有一个方法是早起后洗个热水浴，早上淋浴可以让大脑和身体都清醒过来，原因在于热水能让我们的体温升高。在我们的自主神经中，白天活动的神经——交感神经处于优先地位时，全身大部分内脏器官也会处于活跃状态，体温也较高。反之，如果夜晚休息的神经——副交感神经处于优先地位时，各个内脏器官的活动就会减弱，体温也会有所下降。<strong>所以热水浴能让我们体温升高，白天工作的交感神经就被唤醒了。冷水澡虽然也可以快速激活，但是毕竟有感冒的风险，适用于少部分身体强健的人。</strong></p>
<p>以上就是起床后快速充满活力的方法，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>面试技巧两则</title>
    <url>/changekuan.github.io/2020/02/23/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\changekuan.github.io\assets\css\APlayer.min.css"><script src="\changekuan.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="恐惧"><a href="#恐惧" class="headerlink" title="恐惧"></a>恐惧</h1><h2 id="恐惧的起源"><a href="#恐惧的起源" class="headerlink" title="恐惧的起源"></a>恐惧的起源</h2><p>人生中有很多挑战，比如高考，比如面试。面对这些挑战，大部分人会感到恐惧，怎么才能减轻恐惧呢？心灵鸡汤多半会告诉你，自信来自于实力，多暗示自己“我很强”“我能行”，就能克服恐惧。但其实呢，这种给自己打气的方式，常常是没用的，因为对挑战的恐惧本质上是一种认知障碍，从认知层面入手才能克服。<br>首先，我们来看看恐惧是怎么产生的。恐惧感其实是人类后天学来的。在进化的过程里，人类的老祖宗根据过去的经验，认识到什么是安全的，什么是危险的。于是，遇到危险会恐惧的人，扭头就跑，然后活了下来，遇到危险不知道恐惧的人，就被干掉了。于是，经过这种自然选择，恐惧感就这样被我们人类继承了下来。所以直到现在，我们面对挑战的时候，还会因为恐惧而躲避，这就是为了生存，大脑保留下来的反应机制。</p>
<h2 id="如何战胜恐惧"><a href="#如何战胜恐惧" class="headerlink" title="如何战胜恐惧"></a>如何战胜恐惧</h2><p>知道了恐惧是怎么产生的，你就能明白恐惧这种情绪，其实是无法消失的，给自己打气也没用。那这是不是意味着，我们对恐惧束手无策呢？也不是。我们前边说过，恐惧是人类通过经验学到的，能学会的东西，本质上都是在认知的层面，所以我们可以通过改变认知来克服恐惧。<br>最简单的，你可以通过多次的正强化来改变恐惧感，比如，如果你考了很多次试，成绩都很好，你就不会害怕考试了。<strong>但是，你也发现这里边的问题了，我们经历重大事件的机会其实并不多，没有条件多次正强化，这种情况下该怎么办呢？</strong></p>
<h3 id="避免负面提醒"><a href="#避免负面提醒" class="headerlink" title="避免负面提醒"></a>避免负面提醒</h3><p>第一，我们要避免负面的提醒，比如“别害怕”、“别紧张”。心理学家发现，<strong>当你越强调一件事情的时候，这件事情就会越占据你的意识。</strong>比如，一个小孩子在跑的时候，并不知道“摔倒”是怎么回事，也就没有恐惧感。结果妈妈在后面喊“慢点跑，别摔了”。这个时候，孩子的脑海里就会留下“摔”这个意识，他通过感受妈妈紧张的语气或者表情，意识到“摔”是一件可怕的事，产生了恐惧。他就会更容易失去对自己的步伐控制，更容易摔倒。<br>我们面对挑战的时候也一样，我们小时候并不知道考试的意义，也不会恐惧。但后来上了学，通过观察周围人的反应，我们才对考试有了认知。比如，父母会特别地叮嘱“别紧张，好好考，别考砸了”，他们的态度也在制造恐惧，考好了，父母会夸奖；考差了，父母的态度就很恶劣。再比如，你打算接近一个姑娘，本来你没有多害羞，但身边的人都说“去吧，别害羞”，“害羞”这个念头就开始在你脑海里盘旋。想克服恐惧，就要避免这类负面提醒。</p>
<h3 id="转变主观想法"><a href="#转变主观想法" class="headerlink" title="转变主观想法"></a>转变主观想法</h3><p>第二，别把考试或者面试当成挑战，要把它们当成机会。我们经常能发现，面对同样的考试，同样的面试官，每个人表现出来的恐惧程度是不一样的。这就说明，恐惧是主观的，它更多来自我们的内心。也就是说，当我们把考试或者面试当成了一个“挑战”，我们就会把挑战的对象当成是自己的敌人，对敌人就一定会有攻击性，但面对敌我之间的攻击，恐惧就出现了。<br>如果我们把它当成“表现机会”，敌我关系就不存在了。比如，你学习了一整年，谁能知道你付出了努力呢？所以你需要考个研，来给自己争取一个表现实力的机会。再比如，<strong>面试官应该是一个给自己工作机会的人，他不是来对抗你、挑战你的人，而是送来了可能性的人。当你满怀感激之情的时候，怎么还会恐惧呢？</strong></p>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><p>面试的时候，除了被面试官问各种问题，面试者也可以大胆提出自己的问题。<br>主动提问，既可以表示你对这份工作很有兴趣，想多了解，又可以让你知道这份工作更多的信息。但怎么提出合适的问题呢？新媒体商业内幕网（Business Insider）通过采访一些职业建议专家，给求职者们总结出了六个可以问面试官的问题。</p>
<h2 id="这个职位为什么要招人？"><a href="#这个职位为什么要招人？" class="headerlink" title="这个职位为什么要招人？"></a>这个职位为什么要招人？</h2><p>这个问题能让你知道，是因为之前的员工离职了，还是公司的高速增长需要扩张，或者是其他原因。</p>
<h2 id="为什么大家都想留在你们公司？"><a href="#为什么大家都想留在你们公司？" class="headerlink" title="为什么大家都想留在你们公司？"></a>为什么大家都想留在你们公司？</h2><p>这个问题可以帮助你搞清楚，这家公司的文化、价值观和环境对员工有什么直接影响。</p>
<h2 id="如果我被录用了，在我上班后的头6到12周，公司最希望我做到的三件事是什么？"><a href="#如果我被录用了，在我上班后的头6到12周，公司最希望我做到的三件事是什么？" class="headerlink" title="如果我被录用了，在我上班后的头6到12周，公司最希望我做到的三件事是什么？"></a>如果我被录用了，在我上班后的头6到12周，公司最希望我做到的三件事是什么？</h2><p>这个问题可以帮助你了解面试官和公司对你的预期和标准。</p>
<h2 id="一个人要想成功地干好这份工作，需要哪些东西？"><a href="#一个人要想成功地干好这份工作，需要哪些东西？" class="headerlink" title="一个人要想成功地干好这份工作，需要哪些东西？"></a>一个人要想成功地干好这份工作，需要哪些东西？</h2><p>这个问题可以让你了解面试官对这个职位的理想描述。</p>
<h2 id="我刚才说过的话里，是否有哪些内容让你怀疑我不适合这份工作？"><a href="#我刚才说过的话里，是否有哪些内容让你怀疑我不适合这份工作？" class="headerlink" title="我刚才说过的话里，是否有哪些内容让你怀疑我不适合这份工作？"></a>我刚才说过的话里，是否有哪些内容让你怀疑我不适合这份工作？</h2><p>这样，如果面试官对你有什么疑虑，你就有机会当面解决这些问题，而不是在你没机会为自己辩护的情况下让他自己做决定。</p>
<h2 id="你们什么时候会做最后的决定？我能打电话或发邮件跟进吗？"><a href="#你们什么时候会做最后的决定？我能打电话或发邮件跟进吗？" class="headerlink" title="你们什么时候会做最后的决定？我能打电话或发邮件跟进吗？"></a>你们什么时候会做最后的决定？我能打电话或发邮件跟进吗？</h2><p>这个问题可以让你始终掌握主动权，而不是只能被动等待。</p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++面试题汇总</title>
    <url>/changekuan.github.io/2020/02/22/C-C-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\changekuan.github.io\assets\css\APlayer.min.css"><script src="\changekuan.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h1><h2 id="C-是面向对象的语言"><a href="#C-是面向对象的语言" class="headerlink" title="C++是面向对象的语言"></a>C++是面向对象的语言</h2><p>构造一个符合问题的对象模型。最主要特点是“封装，继承，多态”，隐藏细节，拓展存在的模块，实现接口复用。</p>
<h2 id="动态管理内存方法不一样"><a href="#动态管理内存方法不一样" class="headerlink" title="动态管理内存方法不一样"></a>动态管理内存方法不一样</h2><p>C使用malloc/free，C++还有new/delete。</p>
<h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>C++支持重载，引用。</p>
<p>选择C++的理由：C++更快（相较于java等），有像stl的类库（相较于C）</p>
<p>关于C++输入输出：cin和cout比printf慢</p>
<h1 id="面向对象和面向过程编程的区别"><a href="#面向对象和面向过程编程的区别" class="headerlink" title="面向对象和面向过程编程的区别"></a>面向对象和面向过程编程的区别</h1><p>面向过程：性能高，但是不好维护拓展<br>面向对象：反过来</p>
<h1 id="文件编译执行的四个阶段"><a href="#文件编译执行的四个阶段" class="headerlink" title="文件编译执行的四个阶段"></a>文件编译执行的四个阶段</h1><p>预处理（），编译（汇编代码），汇编（机器指令），链接（exe）</p>
<h1 id="变量的声明和定义"><a href="#变量的声明和定义" class="headerlink" title="变量的声明和定义"></a>变量的声明和定义</h1><p>声明：只是先告诉有这个东西，但是不分配内存</p>
<h1 id="指针引用区别"><a href="#指针引用区别" class="headerlink" title="指针引用区别"></a>指针引用区别</h1><p>指针是一个存储另一个变量地址的新变量。<br>引用只是一个别名。引用必须在初始化的时候被赋值，不能为NULL。</p>
<h1 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h1><p>修饰局部变量：使得变量变成静态变量，生命周期与程序相同。<br>修饰全局变量：使得只能被包含该定义的文件访问。<br>修饰函数：使得只能被包含该定义的文件访问。<br>修饰成员变量：会被类的所有对象共享。<br><strong>涉及到静态就往共享方面去想</strong></p>
<h1 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="#define和const的区别"></a>#define和const的区别</h1><p>定义常量的时候：#define 只是一个立即数，没有类型<br>#define 不能用指针去指向它<br>#define 还可以用来定义简单的函数</p>
<h1 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a>malloc和new的区别</h1><p>Malloc（配套free）是库函数，它的完整作用只对内部类型数据有用。对于非内部类型对象来说，创建的时候自动执行构造函数，消亡的时候自动执行析构函数。<br>New 是运算符，完成内存分配和初始化的工作。</p>
<h1 id="共同体"><a href="#共同体" class="headerlink" title="共同体"></a>共同体</h1><p>意思就是一群人共用一段内存，但不同时存在</p>
<h1 id="delete和delete-的区别"><a href="#delete和delete-的区别" class="headerlink" title="delete和delete[]的区别"></a>delete和delete[]的区别</h1><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数<br>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><p>一个由C/C++编译的程序占用的内存分为以下几个部分</p>
<h2 id="栈区（stack）"><a href="#栈区（stack）" class="headerlink" title="栈区（stack）"></a>栈区（stack）</h2><p>由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<h2 id="堆区（heap）"><a href="#堆区（heap）" class="headerlink" title="堆区（heap）"></a>堆区（heap）</h2><p>一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。<br><strong>注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</strong></p>
<h2 id="全局区（静态区、static）"><a href="#全局区（静态区、static）" class="headerlink" title="全局区（静态区、static）"></a>全局区（静态区、static）</h2><p>全局变量和静态变量的存储是放在这一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放</p>
<h2 id="文字常量区"><a href="#文字常量区" class="headerlink" title="文字常量区"></a>文字常量区</h2><p>常量字符串就是放在这里的。 程序结束后由系统释放</p>
<h2 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a>程序代码区</h2><p>存放函数体的二进制代码</p>
<h1 id="关于内存对齐"><a href="#关于内存对齐" class="headerlink" title="关于内存对齐"></a>关于内存对齐</h1><p>性能要求，快。硬件限制，不能任意访问。</p>
<h1 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h1><p>动态分配的堆内存没有释放，造成系统内存浪费。<br>New和delete没有配套。<br>需要用Delete[]却只用了Delete</p>
<h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>生成实例化对象用的普通构造函数，用一个对象去实例化一个新的对象用的是拷贝构造。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。<br>若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了。</p>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>如果想要用基类对非继承成员进行操作，则要把基类的这个操作（函数）定义为虚函数。那么，析构函数自然也应该如此：如果它想析构子类中的重新定义或新的成员及对象，当然也应该声明为虚的。</p>
<h1 id="静态类型和动态类型"><a href="#静态类型和动态类型" class="headerlink" title="静态类型和动态类型"></a>静态类型和动态类型</h1><p>静态类型：对象在声明时候确定的类型，编译的时候确定。<br>动态类型：当前对象所指的类型，在运行时候确定。</p>
<h1 id="请你写一个string类"><a href="#请你写一个string类" class="headerlink" title="请你写一个string类"></a>请你写一个string类</h1><p>Class string{<br>    Public:<br>        String(const char* str = NULL);<br>        ~String(){};<br>        String(const String &amp; other);<br>        String &amp; operator = (const String &amp;other);<br>    Private:<br>        Char * m_data;<br>}</p>
<p>String::String(const char * str){<br>    If(str == NULL){<br>        M_data = new char[1];<br>M_data = ‘\0’;</p>
<p>}<br>    Int length =<br>M_data = new char [l+1]</p>
<p>Strcpy();<br>}</p>
<h1 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h1><p>结构体默认public，类默认private</p>
<h1 id="STL（必问）"><a href="#STL（必问）" class="headerlink" title="STL（必问）"></a>STL（必问）</h1><p>STL标准模板库，是一些容器的集合。容器、算法、迭代器</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>序列式容器：vector，list，queue，stack，heap<br>关联式容器：平衡二叉树。Map，set，hashtable，hash_set</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>排序，复制，各容器的算法。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>按顺序访问各个元素而无需暴露容器的内部结构。</p>
<h1 id="vector原理"><a href="#vector原理" class="headerlink" title="vector原理"></a>vector原理</h1><p>动态增长，先指向一片连续空间。装不下的时候就申请更大的一片空间，然后将内容复制过去，原来的释放。</p>
<h1 id="unordered-map和map的区别"><a href="#unordered-map和map的区别" class="headerlink" title="unordered_map和map的区别"></a>unordered_map和map的区别</h1><p>一个底层是用红黑树来实现，一个是哈希表</p>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>链表，空间上不连续。如果需要大量插入和删除的时候使用它。</p>
<h1 id="map和set-的底层原理"><a href="#map和set-的底层原理" class="headerlink" title="map和set 的底层原理"></a>map和set 的底层原理</h1><p>原理是红黑树。<br>根节点和叶节点（NULL）是黑色。红色节点的子必须是黑色。节点到自己子孙节点包含相同的黑色节点。决定了没有一条路径会比其他路径长出两倍。接近平衡。</p>
<h1 id="STL的原理和使用"><a href="#STL的原理和使用" class="headerlink" title="STL的原理和使用"></a>STL的原理和使用</h1><p>有些杂乱，是一些用法和原理的说明，看看就好。主要还是要自己把常用的找时间自己去学一学</p>
<p>Sort（a，a+7）<br>迭代器说白了就是指针</p>
<p><strong>String：对char的封装</strong><br>String s;<br>Cout&lt;&lt;s；</p>
<p>获取一行：getline（）；</p>
<p>+= ： 链接字符串。加一个数字是ascii特殊意义：比如10是换行。 想要加10 ，就用a=10；a+‘0’</p>
<p>Sort（s.begin（），s.end（））<br>s.erase(s.begin())</p>
<p>s.substring(第一个位置，要取几个)  几个：-1表示到最后</p>
<p>string s;<br>for(string::iterator it = s.begin();it!=s.end();it++)<br>for(auto iterator it = s.begin();it!=s.end();it++)<br>for(suto x:s)cout&lt;&lt;x;</p>
<p><strong>vector数组</strong><br>Vecor&lt; int &gt; v{4，6};//4大小的数组，初始为6<br>For(auto x:v)cout&lt;&lt;x;<br>v.at(2);<br>v.push_back(6);追加内容<br>resize（10） 重置大小，不赋值，默认为0<br>erase（v.begin）<br>v.front() 第一个元素<br>back（）和end（）-1 是一样的 ，最后一个<br>sort(v.begin(),v.end(),greater&lt; int &gt;()) 从大到小，less从小到大。默认值从小到大<br>for(vector&lt; int &gt;::iterator it = v.begin();it!=v.end();it++)</p>
<p><strong>stack:</strong><br>stack<int> s;<br>s.push(2);<br>s.pop();<br>s.top();<br>10进制转2进制，逆序单词，</p>
<p>Stringstream ss;<br>Ss&lt;&lt;str;流入<br>ss&gt;&gt;num;流出</p>
<p><strong>map：映射。树结构</strong><br>unordered_map</p>
<p>map&lt;标签，值&gt; m；有序的树结构</p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>申论复习笔记</title>
    <url>/changekuan.github.io/2020/02/22/%E5%A6%82%E4%BD%95%E5%A4%8D%E4%B9%A0%E7%94%B3%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\changekuan.github.io\assets\css\APlayer.min.css"><script src="\changekuan.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>首先听完理论课，然后针对性练习，比如极致真题。做完这些题目之后，再回去听课或者看看申论的规矩。我时不时要积累，积累的过程当中可以日常多学习新闻文章的标题，记记近期发生的事情。<br><strong>误区一：把听懂当成学会。</strong><br><strong>误区二：把不会做题当成没听懂。</strong></p>
<h1 id="申论考什么？申论怎么做题？"><a href="#申论考什么？申论怎么做题？" class="headerlink" title="申论考什么？申论怎么做题？"></a>申论考什么？申论怎么做题？</h1><h2 id="阅读理解能力"><a href="#阅读理解能力" class="headerlink" title="阅读理解能力"></a>阅读理解能力</h2><p>抄材料（占百分之三十到百分之四十），提炼材料意思（占百分之三十到百分之四十）。找问题，深入找问题，找原因。</p>
<h2 id="综合分析能力"><a href="#综合分析能力" class="headerlink" title="综合分析能力"></a>综合分析能力</h2><p>对材料进行分析和归纳，总结。多角度思考问题，合理推断。要素之间进行推导推断。对策根据材料中的问题来对应解决。</p>
<p>用说明平实的语言，把话说清楚。准确规范，<strong>不要脱离材料。简明扼要，不要拖拉，多写关键词。短一点。不要自己编。</strong></p>
<h2 id="作答要素和基本题型"><a href="#作答要素和基本题型" class="headerlink" title="作答要素和基本题型"></a>作答要素和基本题型</h2><p>问题、原因、影响、对策。申论是提出问题、解决问题。不要去歌颂。深层次的问题，说出它的原因。好事为什么发生。结果的好坏（意义或者危害）。怎么做。<br>要点要全面，突出关键词，要素之间不是固定的，可以相互转化。</p>
<h2 id="审题："><a href="#审题：" class="headerlink" title="审题："></a>审题：</h2><p>看清做题范围，围绕什么展开，看要求</p>
<h2 id="阅读材料抄哪里"><a href="#阅读材料抄哪里" class="headerlink" title="阅读材料抄哪里"></a>阅读材料抄哪里</h2><p><strong>抄，找关键词。</strong><br><strong>自然段的首尾，总结性的句子。</strong><br><strong>抄政府专家等说的（对策）。老百姓说的（问题）。</strong><br><strong>关联词的句子。</strong></p>
<h1 id="实战举例："><a href="#实战举例：" class="headerlink" title="实战举例："></a>实战举例：</h1><p><img src="http://q61tkpb4n.bkt.clouddn.com/image1.png" alt=""></p>
<p><img src="http://q61tkpb4n.bkt.clouddn.com/image2.png" alt=""></p>
<p>答：经验：选择了积极乐观的生活方式。培养兴趣爱好。持之以恒，坚持不懈。严谨认真，精益求精。及时行动，执行力强。</p>
<p><img src="http://q61tkpb4n.bkt.clouddn.com/image3.png" alt=""></p>
<p>答：增长快，总量大，占比高</p>
<p><img src="http://q61tkpb4n.bkt.clouddn.com/image4.png" alt=""></p>
<p>答：交流少，举办活动少</p>
<h1 id="提问方式"><a href="#提问方式" class="headerlink" title="提问方式"></a>提问方式</h1><h2 id="问原因"><a href="#问原因" class="headerlink" title="问原因"></a>问原因</h2><p>成因，理由，依据，根源。找：与……有关，带来，使得，将会，源于，如果就，随着（发生在题干之前）</p>
<h2 id="问影响："><a href="#问影响：" class="headerlink" title="问影响："></a>问影响：</h2><p>意义，效果，成果，危害，后果<br>找：激发，促进，实现、提升，有利于，感动着，推动了，引发，导致，危及，损害，破坏了，阻止了，致使</p>
<h1 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h1><h3 id="词句解释："><a href="#词句解释：" class="headerlink" title="词句解释："></a>词句解释：</h3><p>谈……的含义，对……解释，对……理解<br>答：是什么（字面意思）+相关要素（深层次解释：问题，危害，意义）+对策（应该怎么做。总结作用。）<br>语言衔接要自然。问题里说有<strong>观点明确</strong>：则回答的时候要表态<br>顺着材料抄下来就对了。</p>
<h1 id="公文题"><a href="#公文题" class="headerlink" title="公文题"></a>公文题</h1><h2 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h2><p>公文题不需要很规范。<br>多也就：标题，称谓，落款<br>在结尾的时候，往往需要号召。一起做，一起干。<br>态度诚恳。问题，危害，意义，对策</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>标题实例：国务院关于坚决稳定市场物价的通知 （不要书名号）<br>称谓：各位……人：  各……部门：<br>落款：右下角（右边留四个格子） 年月日，两个xx一个格子</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>方案类，总结类，宣传类，评论类</p>
<h3 id="方案类："><a href="#方案类：" class="headerlink" title="方案类："></a>方案类：</h3><p>对策放在最中间，其他的背景目的意义放在开头去<br>概括（全部在材料里），提出（可能要有自己写），注意时间节点</p>
<h3 id="总结类："><a href="#总结类：" class="headerlink" title="总结类："></a>总结类：</h3><p>汇报，提纲，讲话稿，调查报告，编者按（摘要）<br>不知道这是什么公文，就按总结类公文来答<br>根据要素分条来总结材料：好处-&gt;问题-&gt;对策</p>
<h3 id="宣传类（号召）："><a href="#宣传类（号召）：" class="headerlink" title="宣传类（号召）："></a>宣传类（号召）：</h3><p>公开信，倡议书，宣传稿<br>问题（好处）+对策+结尾必须有号召<br>事迹：干了什么，品质</p>
<h3 id="评论类："><a href="#评论类：" class="headerlink" title="评论类："></a>评论类：</h3><p>时评，评论文，短评。<br>只要一个标题，介绍评价对象（含义和表现）+观点（支持，避免，辩证，有待观察）<br>评析论证，对策和升华<br>注意精确简练</p>
<h1 id="作文："><a href="#作文：" class="headerlink" title="作文："></a>作文：</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>作文是具有客观性的，不脱离材料。相当于词句解释题。<br>基本上：议论文。论点，论据，论证，对策<br>广东（策论文）：通篇写对策</p>
<p>观点明确且准确，要全面（多写关键词），凸显（好找，明显）<br>论据：贴切，材料之内（不要大段抄）+材料之外（一定要有）<br>结构：完整，各部分紧密连接。一般5~7段。</p>
<p>如果题干有两个切入点，可以写它们各自的意义或者危害，它们之间的关系，它们的对策</p>
<h2 id="读材料"><a href="#读材料" class="headerlink" title="读材料"></a>读材料</h2><p>读作文指定材料，小题没考的材料，权威材料（习大大……）<br>标题拟定<br>比喻式标题：主题➕比喻<br>警醒式标题<br>对称式标题：对策➕意义</p>
<h2 id="作文内容"><a href="#作文内容" class="headerlink" title="作文内容"></a>作文内容</h2><p>社会热点，经典故事，数据，新闻报道<br>名人名言，俗语俚语，领导人讲话<br>礼记：苟日新，日日新，又日新<br>张居正：天下之事不难于立法，而难于法治必行。<br>习近平：文化兴国运兴，文化强民族强。<br>习近平：吃祖宗饭砸子孙碗的事，绝对不能再干，绝对不允许再干<br>习近平：乡村振兴，关键是产业要振兴</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>阅卷老师几乎不看结尾。总结（剩余空格多）或者展望（剩余空格少）就行了</p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>选调生</tag>
        <tag>公务员</tag>
      </tags>
  </entry>
  <entry>
    <title>个人发展战略</title>
    <url>/changekuan.github.io/2020/02/21/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95%E6%88%98%E7%95%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\changekuan.github.io\assets\css\APlayer.min.css"><script src="\changekuan.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一个模型，帮你找到真正热爱的工作"><a href="#一个模型，帮你找到真正热爱的工作" class="headerlink" title="一个模型，帮你找到真正热爱的工作"></a>一个模型，帮你找到真正热爱的工作</h1><h2 id="冰山模型"><a href="#冰山模型" class="headerlink" title="冰山模型"></a>冰山模型</h2><p><img src="http://q61tkpb4n.bkt.clouddn.com/%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B.jpg" alt=""></p>
<p>你和一个岗位是否匹配、匹配程度如何、市场薪资值多少，都可以用这个模型来解释。</p>
<h3 id="知识和技能"><a href="#知识和技能" class="headerlink" title="知识和技能"></a>知识和技能</h3><p>一个人的知识和技能（某项专门的技术）是可以通过后天习得的，也是非常显性，很容易看出来的。<br><strong>如果你的工作中有很多陌生的内容，觉得信息量巨大，来不及接受，感到焦虑和慌乱，那么很可能你的知识技能跟岗位不匹配</strong>，但这不是什么大问题，很容易补齐，努努力，一段时间就能提升。</p>
<h3 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h3><p>能力，或者说通用能力，比如学习思考能力、人际交往能力等。<strong>知识和技能是属于特定领域，而能力则更多的是通用领域的，是可迁移的。</strong><br><strong>如果能力不匹配，在工作中就会体现为工作效率低，面对复杂问题无从下手，缺乏成就感，力不从心。</strong></p>
<h3 id="价值观、性格、动机"><a href="#价值观、性格、动机" class="headerlink" title="价值观、性格、动机"></a>价值观、性格、动机</h3><p>这些要素在成年之后很难改变。<br><strong>如果你在工作中经常陷入矛盾和纠结，对所做的事情很难发自内内心地认同，很可能是价值观上不匹配。</strong><br><strong>如果你在工作中发现，自己好像没有很大的工作量，但是心很累，很有可能是性格不匹配。</strong>你是一个内向的人，在独处中获得能量，但是你做了一份每天要不断和陌生人沟通的工作。<br><strong>如果你在工作中感觉自己没有动力，做事提不起劲来，很可能是工作和你的动机不匹配。</strong>比如你的享受成就感，喜欢挑战，但是你的工作确是高度重复。</p>
<h2 id="模型应用"><a href="#模型应用" class="headerlink" title="模型应用"></a>模型应用</h2><p>工作和伴侣是一样的，匹配比优秀更重要。所有的匹配要素里面，冰山底层的隐形要素起到了更大的作用。就像找伴侣一样，明明表面条件差不多，但是就是对一个人有感觉，对另一个人没感觉。这就是底层隐形要素在发挥作用。<br>但是，岗位这么多，我怎么去找，怎么知道自己匹配哪个岗位呢？</p>
<h3 id="确定要分析的岗位"><a href="#确定要分析的岗位" class="headerlink" title="确定要分析的岗位"></a>确定要分析的岗位</h3><p>根据自身大致情况，先去领英这样的招聘网站，搜某个行业的某个岗位，会出来一堆人，<strong>你看看这些人的履历，他们后来都去了哪里，你就能知道潜在的方向了。</strong>也可以帮你判断这个行业岗位有没有前途。</p>
<h3 id="搜集岗位招聘要求"><a href="#搜集岗位招聘要求" class="headerlink" title="搜集岗位招聘要求"></a>搜集岗位招聘要求</h3><p>不同公司对某个岗位的招聘要求可能不一样，把它们搜集起来，提取共性要求，尽可能的多看几份。</p>
<h3 id="分析这些需求"><a href="#分析这些需求" class="headerlink" title="分析这些需求"></a>分析这些需求</h3><p>对照一下自己，<strong>如果是冰山底层因素不匹配，那么就不太建议选择这个职业。如果是只是技能方面不匹配，那么未必就不能选，这些都是可以后天获得的。</strong>冰山底层隐性因素是你优先考虑的，记住，它最重要。</p>
<h1 id="四大要素，决定了你的市场价值"><a href="#四大要素，决定了你的市场价值" class="headerlink" title="四大要素，决定了你的市场价值"></a>四大要素，决定了你的市场价值</h1><p>首先得有一个认知，<strong>模型越往下的要素，越难培养、越难发现。相对也越能成为竞争优势。同时，下面的要素会影响上面的要素。</strong>例如一个人的知识储备多少，和他的学习能力有关。</p>
<h2 id="四大要素时间投入"><a href="#四大要素时间投入" class="headerlink" title="四大要素时间投入"></a>四大要素时间投入</h2><p>实际表明，，<strong>多把时间投入到底层要素的培养是好的选择。</strong>能力和认知的提升是可以跨行业的，一旦积累到一定的高度，哪怕行业不行，换个地方一样可以值钱。</p>
<h2 id="为什么大多数人不这样做"><a href="#为什么大多数人不这样做" class="headerlink" title="为什么大多数人不这样做"></a>为什么大多数人不这样做</h2><p>大多数人每天打开各种学习产品，学很多碎片化的知识，考各种几个月能拿下来的证。</p>
<h3 id="知识技能比较容易学"><a href="#知识技能比较容易学" class="headerlink" title="知识技能比较容易学"></a>知识技能比较容易学</h3><p>它的门槛低，学习一个新知识，几乎是所有人都能做的。但能力不一样了，<strong>它需要持续的投入，可以的练习，</strong>人们倾向于做容易的事。</p>
<h3 id="受限于目前岗位的定位"><a href="#受限于目前岗位的定位" class="headerlink" title="受限于目前岗位的定位"></a>受限于目前岗位的定位</h3><p>岗位的性质本身就是技能导向型的，对能力没有太高要求，只需要做一件事做得快就好，熟练就好。也就没有动力和意识去提高眼前不需要的、更有价值的能力了。</p>
<h3 id="没有看清工作的本质"><a href="#没有看清工作的本质" class="headerlink" title="没有看清工作的本质"></a>没有看清工作的本质</h3><p>任何工作都是在解决问题，既然是解决一个问题，那么单有一个知识就没有用的。比如你会很多营销理论，但没法帮公司宣传和卖出更多的产品，你就是没有价值的。</p>
<h1 id="四个迹象，发现你的隐藏能力"><a href="#四个迹象，发现你的隐藏能力" class="headerlink" title="四个迹象，发现你的隐藏能力"></a>四个迹象，发现你的隐藏能力</h1><p>努力就会有提升，但是很可能两个起点相同的人，最后努力了结果却不一样。原因很简单，就是努力的方向和天赋问题。<strong>成功人士基本上都是将自己的天赋发挥到了机制。每个人都有自己的天赋，找到它。</strong><br>如何发现自己的天赋所在呢？</p>
<h2 id="自我效能（self-efficacy）"><a href="#自我效能（self-efficacy）" class="headerlink" title="自我效能（self-efficacy）"></a>自我效能（self-efficacy）</h2><p>它的意思是对于某件任务，<strong>你的自信心很强，觉得自己肯定能做好</strong>。当你对某类事情非常有信心，觉得自己能够成功，这就是天赋的一个表现。</p>
<h2 id="本能（instinct）"><a href="#本能（instinct）" class="headerlink" title="本能（instinct）"></a>本能（instinct）</h2><p>意思是，当你还没开始做这件事的时候，你就已经迫不及待想要尝试了。<strong>那些让你迫不及待跃跃欲试的事情，可能就是你的天赋所在。</strong></p>
<h2 id="成长（growth）"><a href="#成长（growth）" class="headerlink" title="成长（growth）"></a>成长（growth）</h2><p>意思是，你发现自己学的很快，相同时间带来更多的成长。<strong>在某个领域你一接触就明显比别人进步快</strong>，这也是天赋给你的信号。</p>
<h2 id="满足（needs）"><a href="#满足（needs）" class="headerlink" title="满足（needs）"></a>满足（needs）</h2><p><strong>做完这件事，及时有些累，你依然感觉有满足感。</strong>这也是天赋的一个信号。<br>那么这些事情我怎么去发现它们呢？</p>
<h2 id="问自己"><a href="#问自己" class="headerlink" title="问自己"></a>问自己</h2><h3 id="关于自我能效"><a href="#关于自我能效" class="headerlink" title="关于自我能效"></a>关于自我能效</h3><p>你认为,自己能够教别人什么?或者,别人常常向你请教什么?<br>你跟他人聊天的时候,倾向聊什么?<br>以及,聊什么话题你会更有自信?<br>你在做什么事情的时候,不会感到焦虑和担心?</p>
<h3 id="本能相关"><a href="#本能相关" class="headerlink" title="本能相关"></a>本能相关</h3><p>你在做什么事情的时候,很少拖延?<br>长时间休假后,你最想念工作的哪个方面、哪个内容?<br>你宁愿放弃休息时间,也要做的事情,是什么?</p>
<h3 id="成长相关"><a href="#成长相关" class="headerlink" title="成长相关"></a>成长相关</h3><p>有什么事情,让你沉浸其中忘记吃饭/睡觉?<br>你在做什么事情的时候,会暂时忘记刷社交网络?<br>你在做什么事情的时候,不容易感到疲倦和厌烦?</p>
<h3 id="满足相关"><a href="#满足相关" class="headerlink" title="满足相关"></a>满足相关</h3><p>过去的工作和生活中,有什么让你获得巨大的成就感和满足感?</p>
<h2 id="问他人"><a href="#问他人" class="headerlink" title="问他人"></a>问他人</h2><p>你觉得,我身上有什么不同于别人的特质?<br>你最欣赏或者佩服我的方面是什么?<br>在你看来,我做什么事情的时候,看起来最兴奋?<br>你曾经看到我做过哪件事情,让你印象深刻?<br>在以下这些方面,你觉得我哪些更加擅长?<br>思维方式:条理清晰、逻辑严密、脑洞很大、专注专业;<br>沟通协调:化解冲突、争取资源、知人善任;<br>计划执行:执行力强、追求完美、目标导向,等等。结果可能会让你有意外发现呢。</p>
<p>问完这些，我相信你会明白很多，找到更正确的努力方向，让你的努力配上你的天赋而如虎添翼吧。</p>
<h1 id="三个方法，将知识内化成能力"><a href="#三个方法，将知识内化成能力" class="headerlink" title="三个方法，将知识内化成能力"></a>三个方法，将知识内化成能力</h1><p>究竟该怎么做，才能将知识内化成能力呢？三个方法：掌握20%的核心，知识和问题相互依靠，系统化训练。（待续……后面补充如何训练与坚持）</p>
]]></content>
      <categories>
        <category>人生</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>纪念</title>
    <url>/changekuan.github.io/2020/02/21/%E7%BA%AA%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\changekuan.github.io\assets\css\APlayer.min.css"><script src="\changekuan.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="它的出生日"><a href="#它的出生日" class="headerlink" title="它的出生日"></a>它的出生日</h1><p>今天是我第一次完成个人网页的搭建的日子，很兴奋。<br>其实好像也没有想象的那么难。<br>还有就是，斥巨资买了一年的 <a href="changekuan.top"></a> 的使用权，有钱真好</p>
<h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><p>没想到配置文件里面，“空格”也很重要，一定不能漏掉，就因为我忘记打空格了，导致我找了一下午的问题所在。官方为啥不告诉我呢。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>开心</tag>
      </tags>
  </entry>
</search>
